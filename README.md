### SecKill
> 这是基于Go语言的一个秒杀系统，这个系统分三层，接入层、逻辑层、管理层。


https://studygolang.com/articles/14981?fr=sidebar
https://www.jianshu.com/p/d789ea15d060
https://yq.aliyun.com/articles/654278


### 秒杀系统简介

秒杀系统不单单适用于电商的抢购场景，其实一切涉及到大并发的场景都适合于使用该套秒杀系统方案，例如互联网金融业务中的抢加息券什么的也可以使用，整个方案中使用到的技术也是日常工作中经常用到的技术。

#### 秒杀系统的难点

在秒杀场景中最大的问题在于容易产生大并发请求、产生超卖现象和性能问题，下面我们分别分析下下面这三个问题：

- 瞬时大并发：一提到秒杀系统给人最深刻的印象是超大的瞬时并发。对于热门商品的抢购场景中一般会有10w＋的用户同时访问一个商品页面去抢购，这就是一个典型的瞬时大并发，如果系统没有经过限流或者熔断处理，那么系统瞬间就会崩掉，就好像被DDos攻击一样；
- 超卖：秒杀除了大并发这样的难点，还有一个所有电商都会遇到的痛，那就是超卖，电商搞大促最怕什么？最怕的就是超卖，产生超卖了以后会影响到用户体验，会导致订单系统、库存系统、供应链等等，产生的问题是一系列的连锁反应，所以电商都不希望超卖发生，但是在大并发的场景最容易发生的就是超卖，不同线程读取到的当前库存数据可能下个毫秒就被其他线程修改了，如果没有一定的锁库存机制那么库存数据必然出错，都不用上万并发，几十并发就可以导致商品超卖；
- 性能：当遇到大并发和超卖问题后，必然会引出另一个问题，那就是性能问题，如何保证在大并发请求下，系统能够有好的性能，让用户能够有更好的体验，不然每个用户都等几十秒才能知道结果，那体验必然是很糟糕的；


【一般的架构图，我们的系统也要使用这个类似的架构图，找出最优方案】

从整个秒杀系统的架构其实和一般的互联网系统架构本身没有太多的不同，核心理念还是通过缓存、异步、限流来保证系统的高并发和高可用。下面从一笔秒杀交易的流程来描述下秒杀系统架构设计的要点：

- 前边是静态页面和CDN简单介绍
- 1）对于大促时候的秒杀活动，一般运营会配置静态的活动页面，配置静态活动页面主要有两个目的一方面是为了便于在各种社交媒体分发，另一方面是因为秒杀活动页的流量是大促期间最大的，通过配置成静态页面可以将页面发布在公有云上动态的横向扩展；
- 2）将秒杀活动的静态页面提前刷新到CDN节点，通过CDN节点的页面缓存来缓解访问压力和公司网络带宽，CDN上缓存js、css和图片；

- 3）将活动H5页面部署在公有云的web server上，使用公有云最大的好处就是能够根据活动的火爆程度动态扩容而且成本较低，同时将访问压力隔离在公司系统外部；

- 4）在提供真正商品秒杀业务功能的app server上，需要进行交易限流、熔断控制，防止因为秒杀交易影响到其他正常服务的提供，我们在限流和熔断方面使用了hystrix，在核心交易的controller层通过hystrix进行交易并发限流控制，当交易流量超出我们设定的限流最大值时，会对新交易进行熔断处理固定返回静态失败报文。


- 5）服务降级处理，除了上面讲到的限流和熔断控制，我们还设定了降级开关，对于首页、购物车、订单查询、大数据等功能都会进行一定程度的服务降级，例如我们会对首页原先动态生成的大数据页面布局降级为所有人看到的是一样的页面、购物车也会降级为不在一级页面的tabbar上的购物车图标上显示商品数量、历史订单的查询也会提供时间周期较短的查询、大数据商品推荐也会提供一样的商品推荐，通过这样的降级处理能够很好的保证各个系统在大促期间能够正常的提供最基本的服务，保证用户能够正常下单完成付款。

如何实现超卖？？？？？？


我们日常的下单过程中防止超卖一般是通过在数据库上实施乐观锁来完成，使用乐观锁虽然比for update这种悲观锁方式性能要好很多，但是还是无法满足秒杀的上万并发需求，我们的方案其实也很简单实时库存的扣减在缓存中进行，异步扣减数据库中的库存，保证缓存中和数据库中库存的最终一致性。


在这个方案中我们使用的分布式缓存是redis，使用了codis集群方案稳定性和高可用方面还是比较有保证的，因为redis是单线程写，所以也不用担心线程安全的问题，redis自身就能够保证数据的强一致性，在下单的事务中包含了实时扣减缓存中的库存和异步发送队列，由队列处理器再异步从队列中取出订单根据订单信息扣减库存系统数据库中的商品数量。

















##### 系统架构图
![image](https://github.com/BlueSimle/SecKill/blob/master/framework.png)

##### 秒杀接入层
1. 从Etcd中加载秒杀活动数据到内存当中。
2. 监听Etcd中的数据变化，实时加载数据到内存中。
3. 从Redis中加载黑名单数据到内存当中。
4. 设置白名单。
5. 对用户请求进行黑名单限制。
6. 对用户请求进行流量限制、秒级限制、分级限制。
7. 将用户数据进行签名校验、检验参数的合法性。
8. 接收逻辑层的结果实时返回给用户。


##### 秒杀逻辑层
1. 从Etcd中加载秒杀活动数据到内存当中。
2. 监听Etcd中的数据变化，实时加载数据到内存中。
3. 处理Redis队列中的请求。
4. 限制用户对商品的购买次数。
5. 对商品的抢购频次进行限制。
5. 对商品的抢购概率进行限制。
6. 对合法的请求给予生成抢购资格Token令牌。

##### 秒杀管理层
1. 添加商品数据。
2. 添加抢购活动数据。
3. 将数据同步到Etcd。
4. 将数据同步到数据库。


##### 目录结构
```
├─sk_admin
│  ├─config
│  ├─controller
│  │  ├─activity
│  │  └─product
│  ├─model
│  ├─service
│  └─setup
├─sk_layer
│  ├─config
│  ├─logic
│  ├─service
│  │  ├─srv_err
│  │  ├─srv_limit
│  │  ├─srv_product
│  │  ├─srv_redis
│  │  └─srv_user
│  └─setup
├─sk_proxy
│  ├─config
│  ├─controller
│  ├─service
│  │  ├─srv_err
│  │  ├─srv_limit
│  │  ├─srv_redis
│  │  └─srv_sec
│  └─setup
└─vendor
    └─github.com
        ├─coreos
        │  └─etcd
        │      └─clientv3
        ├─gin-gonic
        │  └─gin
        ├─go-sql-driver
        │  └─mysql
        ├─gohouse
        │  └─gorose
        ├─spf13
        │  ├─cobra
        │  └─viper
        └─Unknwon
            └─com
```